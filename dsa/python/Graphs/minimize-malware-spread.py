# 924. Minimize Malware Spread
# Hard
# Topics
# Companies
# You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly 
# connected to the jth node if graph[i][j] == 1.

# Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one of those 
# two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will continue until no more 
# nodes can be infected in this manner.

# Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of malware stops. 
# We will remove exactly one node from initial.

# Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize M(initial), return 
# such a node with the smallest index.

# Note that if a node was removed from the initial list of infected nodes, it might still be infected later due to the malware spread.

# Example 1:

# Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# Output: 0
# Example 2:

# Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
# Output: 0
# Example 3:

# Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
# Output: 1

# Constraints:

# n == graph.length
# n == graph[i].length
# 2 <= n <= 300
# graph[i][j] is 0 or 1.
# graph[i][j] == graph[j][i]
# graph[i][i] == 1
# 1 <= initial.length <= n
# 0 <= initial[i] <= n - 1
# All the integers in initial are unique.

from typing import List
from collections import Counter

class UnionFind:
    # With size
    def __init__(self, n: int):
        self.p = list(range(n))
        self.size = [1] * n

    def find(self, x: int):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x: int, y: int) -> bool:
        p1, p2 = self.find(x), self.find(y)

        if p1 == p2:
            return False

        if self.size[p1] > self.size[p2]:
            self.p[p2] = p1
            self.size[p1] += self.size[p2]
        else:
            self.p[p1] = p2
            self.size[p2] += self.size[p1]

        return True

    def get_size(self, x: int):
        return self.size[x]

class Solution:
    def minMalwareSpread(self, graph: List[List[int]], initial: List[int]) -> int:
        n= len(graph)
        # Perform UF updating size
        uf = UnionFind(n)
        for i in range(n):
            for j in range(n):
                if graph[i][j]:
                    uf.union(i, j)

        cnt = Counter(uf.find(x) for x in initial)
        ans, mx = n, 0
        for x in initial:
            root = uf.find(x)
            if cnt[root] > 1:
                continue
            sz = uf.get_size(root)
            if sz > mx or (sz == mx and x < ans):
                ans = x
                mx = sz
        return min(initial) if ans == n else ans

if __name__ == '__main__':
    ans = Solution()
    print(ans.minMalwareSpread(graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]))
    print(ans.minMalwareSpread(graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]))
    print(ans.minMalwareSpread(graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]))

